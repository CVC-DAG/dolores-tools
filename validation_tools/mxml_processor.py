import logging
from pathlib import Path
from typing import List

from lxml import etree
from lxml.etree import _Element as Element

_LOGGER = logging.getLogger(__name__)


class MXMLProcessor:
    def process(self, mxml_file: Path) -> None:
        tree = etree.parse(mxml_file)
        root = tree.getroot()

        # fmt: off

        # Objects that are present in only one place
        self._identify_notes(root)

        self._find_and_ident(root, "attributes/clef")
        self._find_and_ident(root, "attributes/key")
        self._find_and_ident(root, "attributes/time")
        self._find_and_ident(root, "barline")
        self._find_and_ident(root, "direction/direction-type/rehearsal")
        self._find_and_ident(root, "direction/direction-type/pedal")
        # _find_and_ident(root, "note/notations/tuplet")

        # Objects found in various places
        self._find_and_ident(root, "barline/coda", "direction/direction-type/coda")
        self._find_and_ident(root, "barline/fermata", "note/notations/fermata")
        self._find_and_ident(root, "barline/segno", "direction/direction-type/segno")
        self._find_and_ident(root, "note/notations/dynamics", "direction/direction-type/dynamics")

        # Objects defined in parts
        self._identify_beams(root)
        self._identify_end_to_end(root, "note/notations/glissando")
        self._identify_end_to_end(root, "note/notations/slide")
        self._identify_end_to_end(root, "note/notations/slur")
        self._identify_end_to_end(root, "note/notations/tied")
        self._identify_end_to_end(root, "note/notations/tuplet")
        self._identify_end_to_end(root, "direction/direction-type/wedge")
        self._identify_end_to_end(root, "direction/direction-type/octave-shift")
        self._identify_end_to_end(root, "direction/direction-type/bracket")
        self._identify_end_to_end(root, "direction/direction-type/dashes")

        # Other objects
        # _identify_articulations(root)
        # _identify_ornaments(root)
        # _identify_arpeggiate(root)

        # fmt: on

        # Set measure identifiers from the measure numbers
        self._identify_measures(root)

        tree.write(mxml_file)

    def _identify_list(self, elm_list: List[Element], name: str) -> None:
        for ii, node in enumerate(elm_list, 1):
            node.attrib["id"] = f"{name}{ii}"

    def _identify_notes(self, root: Element) -> None:
        nodes = self._find(root, "./part/measure", "note")

        rest_nodes = [x for x in nodes if x.find("rest") is not None]
        note_nodes = [x for x in nodes if x.find("rest") is None]

        self._identify_list(rest_nodes, "rest")
        self._identify_list(note_nodes, "note")

    def _identify_beams(self, root: Element) -> None:
        beams = root.findall("./part/measure/note/beam")
        # beam_stack = {}

        ident = 1

        for beam in beams:
            # We assume all beam elements have numbers, as generated by MuseScore 4
            number = beam.get("number")
            assert number is not None, "NUMBER WITH NONE FOR BEAMS!"

            number = int(number)

            if beam.text == "begin":
                # beam_stack[number] = ident
                beam.set("id", f"beam{ident}")
                ident += 1
            elif beam.text == "backward hook":
                beam.set("id", f"beam{ident}")
                ident += 1
            elif beam.text == "forward hook":
                beam.set("id", f"beam{ident}")
                ident += 1

    def _identify_end_to_end(self, root: Element, *paths: str) -> None:
        elements = self._find(root, "./part/measure", *paths)
        # print(elements)
        idents = {x.split("/")[-1]: 1 for x in paths}

        for element in elements:
            style = element.get("type")
            tag = element.tag

            assert style is not None, "end to end object without style property"

            if style in {
                "start",
                "crescendo",
                "diminuendo",
                "let-ring",
                "up",
                "down",
                "sostenuto",
            }:
                element.set("id", f"{tag}{idents[tag]}")
                idents[tag] += 1

    def _identify_measures(self, root: Element) -> None:
        for part in root.findall("part"):
            part_id = part.get("id")
            for measure in part:
                measure_id = measure.get("number")
                measure.set("id", f"p{part_id}_m{measure_id}")

    def _find(self, root: Element, path_prefix: str, *paths: str) -> List[Element]:
        output = []

        for path in paths:
            output += root.findall(path_prefix + "/" + path)

        return output

    def _find_and_ident(self, root: Element, *paths: str) -> None:
        self._identify_list(
            self._find(root, "./part/measure", *paths),
            paths[0].split("/")[-1],
        )
